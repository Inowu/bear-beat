import { z } from 'zod';
import bcrypt from 'bcrypt';
import { Prisma } from '@prisma/client';
import { TRPCError } from '@trpc/server';
import { publicProcedure } from '../../../procedures/public.procedure';
import { RolesIds } from '../interfaces/roles.interface';
import { ActiveState } from '../interfaces/active-state.interface';
import { generateTokens } from '../procedures/utils/generateTokens';
import stripe, { isStripeConfigured } from '../../../stripe';
import { conektaCustomers } from '../../../conekta';
import { stripNonAlphabetic } from './utils/formatUsername';
import { log } from '../../../server';
import { brevo } from '../../../email';
import { manyChat } from '../../../many-chat';
import { claimManyChatHandoffToken } from '../../../many-chat/handoff';
import { facebook } from '../../../facebook';
import {
  getBlockedEmailDomains,
  normalizeEmailDomain,
} from '../../../utils/blockedEmailDomains';
import {
  getBlockedPhoneNumbers,
  normalizePhoneNumber,
} from '../../../utils/blockedPhoneNumbers';
import { verifyTurnstileToken } from '../../../utils/turnstile';
import { getClientIpFromRequest } from '../../../analytics';
import { serializeUser } from '../utils/serialize-user';

function normalizeUsernameCandidate(value: string): string {
  const trimmed = `${value ?? ''}`.trim();
  if (!trimmed) return '';
  // Keep only characters allowed by the product (letters/numbers/spaces) and collapse spaces.
  return trimmed.replace(/[^a-zA-Z0-9 ]+/g, '').replace(/\s+/g, ' ').trim();
}

async function ensureUniqueUsername(prisma: any, base: string): Promise<string> {
  const normalizedBase = normalizeUsernameCandidate(base);
  let candidate = normalizedBase || 'DJ';

  // Ensure it contains at least one letter to keep the UI friendly and consistent with legacy rules.
  if (!/[a-zA-Z]/.test(candidate)) {
    candidate = `DJ ${candidate}`.trim();
  }

  // Minimum length guard (db + UI expectations).
  if (candidate.length < 3) {
    candidate = `${candidate} DJ`.trim();
  }

  // Limit length to avoid awkward overflows in admin/mobile cards.
  const MAX_LEN = 24;
  const baseShort = candidate.slice(0, MAX_LEN).trim();

  // Try a few suffixes if taken.
  for (let i = 0; i < 8; i += 1) {
    const attempt =
      i === 0
        ? baseShort
        : `${baseShort.slice(0, Math.max(3, MAX_LEN - 5)).trim()} ${Math.floor(
            1000 + Math.random() * 9000,
          )}`.trim();

    const exists = await prisma.users.findFirst({
      where: { username: { equals: attempt } },
      select: { id: true },
    });
    if (!exists) return attempt;
  }

  return `${baseShort.slice(0, Math.max(3, MAX_LEN - 6)).trim()} ${Date.now() % 100000}`.trim();
}

export const register = publicProcedure
  .input(
    z.object({
      // Username is optional (conversion-first). If omitted, we generate one from the email.
      // If provided, it must be simple (letters/numbers/spaces) to keep UX consistent.
      username: z
        .string()
        .optional()
        .default('')
        .transform((v) => `${v ?? ''}`.trim())
        .refine(
          (v) => {
            if (!v) return true;
            if (v.length < 3) return false;
            if (!/^[a-zA-Z0-9 ]*$/.test(v)) return false;
            if (!/[a-zA-Z]/.test(v)) return false;
            return true;
          },
          {
            message:
              'El nombre de usuario debe tener al menos 3 caracteres, incluir una letra y no usar caracteres especiales',
          },
        ),
      email: z.string().email('Email inválido'),
      password: z
        .string()
        .min(6, 'La contraseña debe tener al menos 6 caracteres'),
      // Phone/WhatsApp should not block conversion. If present, we validate uniqueness and blocked lists.
      phone: z.string().optional().default(''),
      fbp: z.string().optional(),
      fbc: z.string().optional(),
      eventId: z.string().optional(),
      url: z.string(),
      // Token generated by ManyChat handoff (optional). Used to link a ManyChat contact to this web account.
      // The token itself contains no PII (server-stored snapshot).
      mcHandoffToken: z
        .string()
        .optional()
        .transform((v) => `${v ?? ''}`.trim()),
      turnstileToken: z
        .string()
        .min(1, 'La verificación de seguridad es requerida'),
    }),
  )
  .mutation(
    async ({
      input: { username, email, password, phone, fbp, fbc, eventId, url, mcHandoffToken, turnstileToken },
      ctx: { req, prisma },
    }) => {
      const clientIp = getClientIpFromRequest(req);
      await verifyTurnstileToken({
        token: turnstileToken,
        remoteIp: clientIp ?? req.ip,
      });

      const emailDomain = normalizeEmailDomain(email);
      if (emailDomain) {
        const blockedDomains = await getBlockedEmailDomains(prisma);
        if (blockedDomains.includes(emailDomain)) {
          throw new TRPCError({
            code: 'BAD_REQUEST',
            message: 'El dominio del correo no está permitido',
          });
        }
      }

      const normalizedPhone = normalizePhoneNumber(phone || '');
      if (normalizedPhone) {
        const blockedPhones = await getBlockedPhoneNumbers(prisma);
        if (blockedPhones.includes(normalizedPhone)) {
          throw new TRPCError({
            code: 'BAD_REQUEST',
            message: 'El teléfono no está permitido',
          });
        }
      }

      const existingUser = await prisma.users.findFirst({
        where: { email: { equals: email } },
        select: { id: true },
      });

      if (existingUser?.id) {
        throw new TRPCError({
          code: 'BAD_REQUEST',
          message: 'Ese email ya está registrado',
        });
      }

      if (normalizedPhone) {
        const existingUserWithPhone = await prisma.users.findFirst({
          where: {
            phone: {
              equals: normalizedPhone,
            },
          },
        });

        if (existingUserWithPhone) {
          throw new TRPCError({
            code: 'BAD_REQUEST',
            message: 'Ese teléfono ya está registrado',
          });
        }
      }

      const usernameFromEmail = normalizeUsernameCandidate(email.split('@')[0] ?? '');
      const finalUsername = username
        ? normalizeUsernameCandidate(username)
        : await ensureUniqueUsername(prisma, usernameFromEmail || 'DJ');

      if (username) {
        const existingUserWithUsername = await prisma.users.findFirst({
          where: { username: { equals: finalUsername } },
          select: { id: true },
        });
        if (existingUserWithUsername?.id) {
          throw new TRPCError({
            code: 'BAD_REQUEST',
            message: 'Ese nombre de usuario ya está registrado',
          });
        }
      }

      // TODO: Send confirmation email and generate token
      const baseUserData = {
        email,
        password: bcrypt.hashSync(password, 10),
        phone: normalizedPhone || null,
        role_id: RolesIds.normal,
        ip_registro: clientIp ?? req.ip,
        // `registered_on` is stored as DATE in MySQL (@db.Date). Use Date objects so Prisma
        // formats it correctly for the database.
        registered_on: new Date(),
        active: ActiveState.Active,
        verified: process.env.NODE_ENV === 'production' ? false : true,
      };

      const userProvidedUsername = Boolean(username);
      let newUser;
      try {
        newUser = await prisma.users.create({
          data: {
            ...baseUserData,
            username: finalUsername,
          },
        });
      } catch (e: any) {
        if (e instanceof Prisma.PrismaClientKnownRequestError && e.code === 'P2002') {
          const targets = Array.isArray(e.meta?.target) ? (e.meta?.target as string[]) : [];
          if (targets.includes('email')) {
            throw new TRPCError({ code: 'BAD_REQUEST', message: 'Ese email ya está registrado' });
          }
          if (targets.includes('phone')) {
            throw new TRPCError({ code: 'BAD_REQUEST', message: 'Ese teléfono ya está registrado' });
          }
          if (targets.includes('username')) {
            if (userProvidedUsername) {
              throw new TRPCError({
                code: 'BAD_REQUEST',
                message: 'Ese nombre de usuario ya está registrado',
              });
            }
            // Rare race: regenerate and retry once.
            const retryUsername = await ensureUniqueUsername(prisma, finalUsername);
            newUser = await prisma.users.create({
              data: {
                ...baseUserData,
                username: retryUsername,
              },
            });
          } else {
            throw new TRPCError({ code: 'BAD_REQUEST', message: 'No se pudo crear el usuario' });
          }
        } else {
          throw e;
        }
      }

      if (isStripeConfigured()) {
        try {
          const customer = await stripe.customers.create({
            email,
            metadata: {
              id: String(newUser.id),
              userId: String(newUser.id),
            },
          });

          await prisma.users.update({
            where: {
              id: newUser.id,
            },
            data: {
              stripe_cusid: customer.id,
            },
          });
        } catch (e) {
          log.error(
            `There was an error creating the stripe customer for user ${newUser.id}`,
          );
        }
      } else {
        log.debug('[REGISTER] Stripe not configured; skipping customer creation', {
          userId: newUser.id,
        });
      }

      const hasConektaKey = Boolean(
        process.env.CONEKTA_KEY?.trim() || process.env.CONEKTA_TEST_KEY?.trim(),
      );
      if (hasConektaKey) {
        try {
          const customer = await conektaCustomers.createCustomer({
            email,
            name: stripNonAlphabetic(newUser),
            phone: newUser.phone ?? '',
            metadata: {
              id: newUser.id,
            },
          });

          await prisma.users.update({
            where: {
              id: newUser.id,
            },
            data: {
              conekta_cusid: customer.data.id,
            },
          });
        } catch (e: any) {
          log.error(
            `There was an error creating the conekta customer for user ${
              newUser.id
            }, details: ${JSON.stringify(e.response?.data?.details)}`,
          );
        }
      } else {
        log.debug('[REGISTER] Conekta not configured; skipping customer creation', {
          userId: newUser.id,
        });
      }

      const hasBrevoKey = Boolean(process.env.BREVO_API_KEY?.trim());
      if (hasBrevoKey) {
        try {
          log.info('[REGISTER] Sending email to user');
          await brevo.smtp.sendTransacEmail({
            templateId: 3,
            to: [{ email: newUser.email, name: newUser.username }],
            params: {
              NAME: newUser.username,
              EMAIL: newUser.email,
            },
          });
        } catch (e: any) {
          log.error(`[REGISTER] Error while sending email ${e.message}`);
        }
      } else {
        log.debug('[REGISTER] Brevo not configured; skipping welcome email', {
          userId: newUser.id,
        });
      }

      const userAgentRaw = req.headers['user-agent'];
      const userAgent =
        typeof userAgentRaw === 'string'
          ? userAgentRaw
          : Array.isArray(userAgentRaw)
            ? userAgentRaw[0] ?? null
            : null;

      try {
        log.info('[REGISTER] Sending sign up event to Facebook CAPI');
        await facebook.setEvent(
          'CompleteRegistration',
          clientIp,
          userAgent,
          { fbp, fbc, eventId },
          url,
          newUser,
        );
      } catch (error) {
        log.error('[REGISTER] Error sending CAPI event', {
          error: error instanceof Error ? error.message : error,
        });
      }

      // If the user arrived from a ManyChat flow (IG/FB/WhatsApp), claim the handoff token and
      // (best-effort) link the ManyChat contact id to this user to make tags/custom fields reliable.
      if (mcHandoffToken) {
        try {
          const claimed = await claimManyChatHandoffToken({
            prisma,
            token: mcHandoffToken,
            userId: newUser.id,
          });

          if (claimed.ok) {
            const contactId = `${claimed.contactId ?? ''}`.trim();

            // Best-effort: push system fields (email/phone) into the existing ManyChat contact.
            // ManyChat IDs are long numeric strings; do NOT coerce to Number.
            if (contactId) {
              try {
                await manyChat.updateSubscriber(
                  {
                    first_name: newUser.first_name,
                    last_name: newUser.last_name,
                    phone: newUser.phone ?? undefined,
                    email: newUser.email,
                  },
                  contactId,
                  'Consent',
                );
              } catch {
                // noop
              }
            }
          }
        } catch (error) {
          log.debug('[REGISTER] ManyChat handoff claim skipped (non-blocking)', {
            userId: newUser.id,
            error: error instanceof Error ? error.message : error,
          });
        }
      }
      // This implicitly creates a new subscriber in ManyChat or retrieves an existing one
      try {
        await manyChat.addTagToUser(newUser, 'USER_REGISTERED');
      } catch (error) {
        log.warn('[REGISTER] ManyChat tag failed (non-blocking)', {
          error: error instanceof Error ? error.message : error,
          userId: newUser.id,
        });
      }

      const tokens = await generateTokens(prisma, newUser);

      return {
        ...tokens,
        message: 'Usuario fue creado correctamente',
        user: serializeUser(newUser),
      };
    },
  );
